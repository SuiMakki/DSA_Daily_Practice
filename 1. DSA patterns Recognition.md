Here are the essential DSA patterns formatted as high-impact flashcards. You can use these to quiz yourself on "Recognition" (The Keyword) vs. "Resolution" (The Pattern).

---

### **Pattern: Sliding Window**

* **Keywords:** Contiguous, subarray, substring, window size, max/min sum of  elements.
* **Use Case:** When you need to track a sub-range of elements that moves across a linear data structure.

### **Pattern: Two Pointers**

* **Keywords:** Sorted array/list, pair, triplet, sum, "at both ends," remove duplicates in-place.
* **Use Case:** When you need to compare or find elements in a sorted collection without nested loops.

### **Pattern: Fast & Slow Pointers (Tortoise & Hare)**

* **Keywords:** Cycle, loop, middle of Linked List, Palindrome Linked List.
* **Use Case:** Detecting cycles or finding specific positions in a list in  time with  space.

### **Pattern: Binary Search**

* **Keywords:** Sorted, "Find the index," "Maximize the minimum," , search space.
* **Use Case:** When the input is sorted or you can discard half of the search space in each step.

### **Pattern: Monotonic Stack**

* **Keywords:** Next Greater Element, Previous Smaller, Histogram, Stock Span, "Nearest."
* **Use Case:** When you need to find the first element to the left or right that satisfies a size comparison.

### **Pattern: Top K Elements (Heap)**

* **Keywords:** Top ,  largest,  smallest, most frequent, priority queue.
* **Use Case:** When you don't need to sort the whole list, just track the  extreme values.

### **Pattern: Breadth-First Search (BFS)**

* **Keywords:** Shortest path (unweighted), level-order, nearest, minimum steps/moves.
* **Use Case:** Exploring nodes layer by layer; guaranteed shortest path in a simple graph.

### **Pattern: Depth-First Search (DFS)**

* **Keywords:** All paths, tree traversal (Pre/In/Post), connectivity, recursion, backtracking.
* **Use Case:** Exploring as far as possible along a branch before backtracking.

### **Pattern: Dynamic Programming (DP)**

* **Keywords:** Overlapping subproblems, "Count the number of ways," "Find the max/min cost," memoization.
* **Use Case:** When a large problem can be broken into smaller, repeating sub-problems.

### **Pattern: Backtracking**

* **Keywords:** All permutations, subsets, Sudoku, N-Queens, "Try all possibilities."
* **Use Case:** When you need to build a solution incrementally and "undo" steps that fail constraints.

### **Pattern: Prefix Sum**

* **Keywords:** Range sum queries, "Sum from  to ," subarray sum equals .
* **Use Case:** When you need to perform multiple sum calculations over intervals in  time.

### **Pattern: Union-Find (Disjoint Set Union)**

* **Keywords:** Connected components, "Are these two in the same set?", cycle detection in undirected graphs.
* **Use Case:** Grouping elements and checking connectivity efficiently.

---
You're right to double-check—while those 12 are the "heavy hitters" that cover about 80% of interview questions, there are several more specialized patterns used in advanced DSA.

To be truly comprehensive, here are the remaining patterns that round out the complete toolkit:

---

### **13. Cyclic Sort**

* **Keywords:** Numbers  to , "find the missing," "find duplicates," unsorted range.
* **Use Case:** When the input is an array of integers in a specific range and you need to sort them in  time.

### **14. Overlapping Intervals (Merge Intervals)**

* **Keywords:** Range, intervals, meeting rooms, "find overlaps," "merge time slots."
* **Use Case:** Dealing with problems involving schedules or coordinate ranges.

### **15. K-way Merge**

* **Keywords:** Merge  sorted lists, "find the  smallest in  arrays."
* **Use Case:** Combining multiple sorted data streams into one, usually using a Heap.

### **16. Topological Sort (Kahn’s Algorithm)**

* **Keywords:** Dependency, "order of tasks," prerequisites, Directed Acyclic Graph (DAG).
* **Use Case:** When tasks must be completed in a specific order based on dependencies.

### **17. Trie (Prefix Tree)**

* **Keywords:** Dictionary, prefix, autocomplete, "find all words starting with," XOR of numbers.
* **Use Case:** Storing and searching strings or bit manipulations where prefixes matter.

### **18. Bit Manipulation**

* **Keywords:** XOR, parity, "find the non-repeating number," binary representation, subsets.
* **Use Case:** Optimizing space or solving problems involving binary properties of integers.

### **19. Tree Island (Matrix DFS/BFS)**

* **Keywords:** Grid, matrix, "number of islands," "connected cells," "flood fill."
* **Use Case:** Navigating a 2D array as if it were a graph.

### **20. Segment Tree / Fenwick Tree (Binary Indexed Tree)**

* **Keywords:** Point updates, range queries, "update  and find sum/min in range  to ."
* **Use Case:** Advanced range-based problems where the data is constantly changing.

### **21. Modified Binary Search**

* **Keywords:** Rotated sorted array, "search in a nearly sorted array," "infinite array."
* **Use Case:** Standard binary search isn't enough because the sorted property is slightly broken.

---

### **Summary Table for Quick Reference**

| Category | Patterns |
| --- | --- |
| **Arrays / Strings** | Sliding Window, Two Pointers, Prefix Sum, Cyclic Sort, Monotonic Stack |
| **Sorting / Searching** | Binary Search, Merge Intervals, K-way Merge |
| **Linked Lists** | Fast & Slow Pointers, In-place Reversal |
| **Trees / Graphs** | BFS, DFS, Topological Sort, Trie, Union-Find, Matrix DFS/BFS |
| **Optimization** | DP, Greedy, Backtracking, Heaps (Top K) |
| **Advanced** | Segment Trees, Bit Manipulation |
