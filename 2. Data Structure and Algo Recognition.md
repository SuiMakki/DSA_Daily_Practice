To help you choose the right tool for the job, I’ve broken this down into **Data Structures** (the "How we store it") and **Algorithms** (the "How we process it").

---

## **Part 1: Data Structures Flashcards**

### **Array / String**

* **When:** Constant-time access is needed; data is linear; size is known or fixed.
* **Keyword:** Index, contiguous, O(1) access.

### **Linked List**

* **When:** Frequent insertions/deletions at the head or middle; size is dynamic.
* **Keyword:** No random access, pointers, constant-time insertion/deletion.

### **Stack (LIFO)**

* **When:** Need to reverse things; keep track of the most recent state (Undo/Redo); nested structures.
* **Keyword:** Recursion, balancing brackets, depth-first, "Last-In, First-Out."

### **Queue (FIFO)**

* **When:** Order of arrival matters; processing tasks in sequence.
* **Keyword:** First-come first-served, BFS, "First-In, First-Out."

### **Hash Table / Map / Set**

* **When:** Need  search, insertion, and deletion; checking for duplicates.
* **Keyword:** Frequency count, unique elements, "Is this present?", lookup.

### **Heaps (Priority Queue)**

* **When:** Need instant access to the **minimum** or **maximum** element while adding new data.
* **Keyword:** Top K, largest/smallest, streaming data, scheduling.

### **Binary Search Tree (BST)**

* **When:** Data needs to be sorted and searchable efficiently ().
* **Keyword:** Sorted order, range queries, predecessor/successor.

### **Trie (Prefix Tree)**

* **When:** Searching for strings by prefix; saving space for common prefixes.
* **Keyword:** Autocomplete, dictionary, word validation.

### **Graph**

* **When:** Data is interconnected (social networks, maps, dependencies).
* **Keyword:** Nodes, edges, relationships, networks.

---

## **Part 2: Algorithms Flashcards (Where/When)**

### **Sorting Algorithms**

* **Quick Sort/Merge Sort:** Standard efficient sorting ().
* **Counting/Radix Sort:** Sorting integers within a small, known range ().
* **Bubble/Insertion:** Only for very small datasets or nearly sorted data.

### **Searching Algorithms**

* **Linear Search:** Unsorted data; search once.
* **Binary Search:** Sorted data; search many times.

### **Graph Algorithms**

* **Dijkstra’s:** Shortest path in a **weighted** graph (no negative weights).
* **Bellman-Ford:** Shortest path in a graph with **negative** weights.
* **Prim’s / Kruskal’s:** Finding the **Minimum Spanning Tree** (cheapest way to connect all nodes).

### **String Matching**

* **KMP (Knuth-Morris-Pratt):** Finding a pattern within a large text efficiently.
* **Rabin-Karp:** Using hashing to find a pattern in a string.

### **Bit Manipulation**

* **When:** Memory is tight; operations need to be lightning fast; checking powers of 2.
* **Keyword:** Binary, XOR, bitmask.

---

## **The Ultimate Decision Table**

| If you want to... | Use this Data Structure | Use this Algorithm |
| --- | --- | --- |
| **Find the shortest path** | Queue / Graph | BFS (unweighted) / Dijkstra (weighted) |
| **Store "seen" items** | Hash Set | N/A |
| **Track frequency** | Hash Map | N/A |
| **Find min/max in dynamic data** | Heap (Priority Queue) | Heapify |
| **Solve "dependency" order** | Graph | Topological Sort (Kahn's) |
| **Find if a path exists** | Stack / Graph | DFS |
| **Handle undo/redo** | Stack | N/A |
| **Manage printer tasks** | Queue | N/A |
